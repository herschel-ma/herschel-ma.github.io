[{"content":"Major GC、Minor GC、Full GC JVM 在进行 GC 时，并非每次都对上面三个内存（新生代、老年代、方法区）区域一起回收的，大部分时候回收的都是指新生代。\n针对HotSpot VM 的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）。\n  部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：\n 新生代收集（Minor GC/Young GC）：只是新生代（Eden,s0,s1）的垃圾收集。 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集。  目前，只有 CMS GC 会有单独收集老年代的行为。 注意：很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。   混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。  目前，只有G1 GC会有这种行为      整堆收集（Full GC）：收集整个 java 堆和方法区的垃圾收集。\n  最简单的分代式GC策略的触发条件 年轻代GC（Minor GC）的触发机制  当年轻代空间不足时，就会触发Minor GC，这里的年轻代指的是 Eden 代满，Survivor 满不会引发GC。（每次Minor GC 会清理年轻代的内存。） 因为 Java 对象大多都具备朝生夕死的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。 Minor GC会引发 STW ，暂停其他用户线程，等垃圾回收结束，用户线程才恢复运行。  老年代（Major GC/Full GC）触发机制  指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或者“Full GC”发生了。 出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。  也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC。   Major GC的速度一般会比Minor GC 慢10倍以上，STW的时间更长。 如果Major GC后，内存还不足，就报 OOM 了。  Full GC 触发机制 触发 Full GC 执行的情况有下面五种：\n1. 调用 System.gc() 时，系统建议执行 Full GC，但是不必然执行\n2. 老年代空间不足\n3. 方法区空间不足\n4. 通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存\n5. 由 Eden 区，survivor space0（From Space）区向 survivor space1（To Space）区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。\n说明：full gc 是开发或调优中尽量要避免的，这样暂时时间短一些。\n堆空间分代思想 其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没有用。这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间来。\n内存分配策略 对象提升(Promotion)规则 如果对象在 Eden 出生并经过第一次 MinorGC 之后仍然存活，并且能够被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。对象在 survivor 区中每熬过一次 MinorGC, 年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个 JVM、每个 GC 都有所不同）时，就会被晋升到老年代中。\n对象晋升到老年代的年龄阈值，可以通过选项 -XX：MaxTenuringThrehold 来设置。\n","description":"","id":4,"section":"posts","tags":["JVM Java"],"title":"MinorGC_MajorGC_FullGC","uri":"http://herschel-ma.github.io/posts/minorgc_majorgc_fullgc/"},{"content":"堆的核心概述  一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。 Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存空间。  堆内存的大小是可以调节的。   《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。 所有的线程共享 Java 堆，在这里还可以划分为线程私有的缓冲区（Thread Local Allocation Buffer,TLAB）。 《Java虚拟机规范》中对 Java 堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instance and arrays is allocated）  “几乎”所有的对象实例都在这里分配内存。——从世界使用角度看的   数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。 在方法结束后，堆的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。 堆，是 GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。  内存细分  Java 8 及之后堆内存逻辑上分为三部分：新生区、养老区、元空间。  设置堆内存大小与 OOM  Java 堆区用于存储 Java 对象实例，那么堆的大小在 JVM 启动时就已经设定好了，大家可以通过“-Xmx”和“-Xms”来进行设置。  “-Xms”用于表示堆区的起始内存，等价于 -XX：InitialHeapSize “-Xmx”则用于表示堆区的最大内存，等价于 -XX：MaxHeapSize   一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出 OutOfMemoryError 异常。 通常会将 -Xms 和 -Xmx 两个参数配置相同的值，其目的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。 默认情况下，初始内存大小：物理电脑内存大小/64， 最大内存大小：物理电脑内存大小/4。  年轻代与老年代   一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。\n  另外一类对象的生命周期却非常长，在某些极端的情况下还能够与 JVM 的生命周期保持一致。\n  Java 堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）\n  其中年轻代又可以划分为 Eden 空间，Survivor0 空间和 Survivor1 空间（有时也叫做 from 区、to 区）。\n  下面这参数开发中一般不会调：\n 默认 -XX：NewRatio=2,表示新生代占1，老年代占2，新生代占整个堆的1/3 可以修改 -xx:NewRatio=4, 表示新生代占1，老年代占4，新生代占整个堆的1/5。    在 HotSpot 中，Eden 空间和另外两个 Survivor 空间缺省所占的比例是 8:1:1\n  当然开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如-XX：SurvivorRatio=8\n XX:SurvivorRatio:设置新生代中Eden区与Survivor区的比例 XX:-useAdaptiveSizePolicy:关闭自适应的内存分配策略（暂时用不到）    几乎所有的 Java 对象都是在 Eden 区被 new 出来的\n  绝大部分的 Java 对象的销毁都在新生代进行了。\n IBM 公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。    可以使用选项“-Xmn”设置新生代最大内存大小\n 这个参数一般使用默认值就可以了。    对象分配过程：概述  为新对象分配内存是一件非常严谨而复杂的任务，JVM的设计者们不仅需要考\u001a内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完毕内存回收后是否会在内存空间中产生内存碎片。   new 的对象先放在伊甸园区，此区有大小限制。 当伊甸园的空间填满时，程序又要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到伊甸园区。 然后将伊甸园区中的剩余对象移动到幸存者0区。 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。 啥时候能去养老区呢？可以设置次数，默认是15次。  可以设置参数: -XX:MaxTenuringThreshold=\u0026lt;N\u0026gt;进行设置。    总结  针对幸存者 s0，s1 区的总结：复制之后有交换，谁空谁是to. 关于垃圾回收：频繁再新生区收集，很少在养老区收集，几乎不在永久区/元空间收集  常用调优工具  JDK命令行 Eclipse: Memory Analyzer Tool Jconsole Visual VM Jprofiler Java Flight Recorder GCViewer GC Easy  ","description":"","id":5,"section":"posts","tags":["JVM","java"],"title":"堆空间的概述","uri":"http://herschel-ma.github.io/posts/%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A6%82%E8%BF%B0/"},{"content":"方法返回地址   存放调用该方法的 pc 寄存器的值。\n  一个方法的结束，有两种方式：\n 正常执行完成 出现未处理的异常，非正常退出    无论通过哪种方式退出，在方法退出后都返回该方法被调用的位置，方法正常退出时，**调用者的 pc 寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址。**而通过异常退出的，返回地址是通过异常表来确定，栈帧中一般不会保存这部分信息。\n  本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈，将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去。\n  当一个方法开始执行后，只有两种方式可以退出这个方法：\n 执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口。  一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。 在字节码指令中，返回指令包含 ireturn（当返回值是 boolean、byte、char、short和 int 类型的时候使用）、lreturn、freturn、dreturn 以及 areturn，另外还有一个 return 指令提供声明为 void 的方法、实例初始化方法、类和接口的初始化方法使用。   在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。\n方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。    本地方法 本地方法接口的理解  简单来讲，本地方法就是一个 Java 调用非 Java 代码的接口。一个 Native Method 是这样一个 Java 方法：该方法的实现由非 Java 语言完成，比如 C 。这个特征并非只有 Java 语言才有，比如在 C++ 中，你可以用 extern \u0026quot;C\u0026quot; 来告诉 C++ 编译器调用一个 C 的函数。 在定义一个 native method 的时候，并不提供实现体（有些像定义一个 Java Interface），因为其实现体是由非 java 语言在外面实现的。 本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++ 程序。  为什么要使用 Native Method? Java 使用起来很方便，但是有些层次的任务用 Java 实现起来不容易，或者我们对程序的效率很在意时，问题就来了\n与 Java 环境外交互 有时 Java 语言需要与 Java 外面的环境交互，这是本地方法存在的主要原因。 你可以想想 Java 需要与操作系统或者其他硬件交换信息时的情况。本地方法正是这样一种交流机制，是一种非常简洁的接口，而且我们不需要去了解 Java 之外的繁琐的细节。\n与操作系统交互 JVM 支持着 Java 本身和运行时库，它是 Java 赖以生存的平台，它是由一个解释器（解释字节码）和一些连接本地代码的库组成的。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用 Java 实现了 jre 与底系统交互，甚至 JVM 的一部分就是用 C 写的。还有，如果我们要使用一些 Java 没有封装的操作系统的特性时，也要使用本地方法。\nSun\u0026rsquo;s Java Sun 的解释器就是用 C 实现的，这使得它能够像一些普通的 C 一样与外部交互。jre 大部分是用 Java 实现的，它也通过一些本地方法与外界交互。类 java.lang.Thread 的 setPriority() 方法是用 Java 实现的，但它实现调用的是该类里的本地方法 setPriority0()。这个本地方法是用 C 实现的，并被移植到 JVM 内部，在 Windows 95 平台上，这个本地方法最终会调用 Win32 setPriority() API。这是一个本地方法的具体实现由 JVM 直接提供，更多情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被 JVM 调用。\n本地方法栈  Java 虚拟机栈用于管理 Java 方法的调用，本地方法栈用于管理本地方法的调用。 本地方法栈，也是线程私有的。 允许被实现成固定或者是可扩展的内存大小。（在内存溢出方面是一样的）  如果线程请求分配的栈容量超过了本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常。 如果本地方法栈可以扩展，并且在扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。 本地方法是使用 C 语言实现的。 它的具体做法是在 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。   当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。他和虚拟机拥有同样的权限。  本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。 它甚至可以直接使用本地处理器中的寄存器。 直接从本地方法的堆中分配任意数量的内存。   并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。 在 Hospot JVM 中，直接将本地方法栈和虚拟机栈合二为一。  ","description":"","id":6,"section":"posts","tags":["Java","JVM"],"title":"方法返回地址","uri":"http://herschel-ma.github.io/posts/%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80/"},{"content":"How to list imported modules  How to enumerate all imported modules? E.g. I would like to get [\u0026lsquo;os\u0026rsquo;,\u0026lsquo;sys\u0026rsquo;] from this code:  1 2  import sys import os   Answer liked most  所有加载模块都会出现在sys.moudles中  1 2  import sys sys.moudles.keys()    An approximation of getting all imports for the current module only would be to inspect globals() for modules:  1 2 3 4 5 6 7 8 9  import types def imports(): for name, val in globals.items(): if isinstance(val, types.MoudleType): yield val.__name__ imported_moudles = [i for i in imports()] print(imported_moudles)    This won\u0026rsquo;t return local imports, or non-moudle imports like from x import y. Note that this returns val.__name__ so you get the original module name if you used import moudle as alias; yield name instead if you want the alias.  dynamically import  以下两种方式均可将变量或者包名的字符串传入，动态加载模块。  exec() __import__()    ","description":"如何知道自己当前模块引入了多少包呢？怎么动态加载包呢？","id":7,"section":"posts","tags":["python"],"title":"动态导包和已导入的模块","uri":"http://herschel-ma.github.io/posts/%E5%8A%A8%E6%80%81%E5%AF%BC%E5%8C%85%E5%92%8C%E5%B7%B2%E5%AF%BC%E5%85%A5%E7%9A%84%E6%A8%A1%E5%9D%97/"},{"content":"方法的调用：虚方法与非虚方法 4种方法调用指令   虚拟机中提供了以下几条方法调用指令：\n  普通调用指令：\n invokestatic: 调用静态方法，解析阶段唯一确定唯一方法版本 invokespecial: 调用方法、私有及父类方法，解析阶段确定唯一方法版本 invokevirtual: 调用所有虚方法 invokeinterface: 调用接口方法    动态调用指令：\n5. invokedynamic: 动态解析处需要调用的方法，然后执行。\n    前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 invokedynamic 指令则支持由用户确定方法版本，其中 invokestatic 指令和 Invokespecial 指令调用的方法称为非虚方法，其余的(final修饰的除外)称为虚方法。\n  方法的调用：关于 invokedynamic 指令  JVM 字节码指令集一直比较稳定，一直到 Java7 中才增加了一个 invokedynamic 指令，这是Java 为了实现「动态类型语言」支持而做的一种改进。 但是在 Java7 中并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令。直到Java8 的 Lambda 表达式的出现，invokedynamic 指令的生成，在 Java 中才有了直接的生成方式。 Java7 中增加的动态语言类型支持的本质式对 Java 虚拟机规范的修改，而不是对 Java 语言规则的修改，这一块相对来说比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在 Java 平台的动态语言的编译器。  动态类型语言和静态类型语言  动态类型语言和静态类型语言两者的区别在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之就是动态类型语言。 说的再直白一点就是，**静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息。**这是动态语言的一个重要特征。  方法的调用：方法重写的本质 Java 语言中方法重写的本质  找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C 。 如果在类型 C 中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常。 否则，按照继承关系从下往上一次对 C 的各个父类进行第 2 步的搜索与验证过程。 如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常。  IllegalAccessError 介绍：  程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。  方法的调用：虚方法表  在面向对象的编程中，会很频繁的使用动态分配，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM 采用在类的方法区建立一个虚方法表（ virtual method table ）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。 那么虚方法表是什么时候被创建？ 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。\n  ","description":"方法的调用","id":8,"section":"posts","tags":["JVM","Java"],"title":"4种方法调用指令","uri":"http://herschel-ma.github.io/posts/4%E7%A7%8D%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"content":"虚拟机栈概述   由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所有不能设计为基于寄存器的。\n  优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。\n  内存中的栈和堆  栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。  虚拟机栈的基本内容   Java 虚拟机栈是什么？\n Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时，都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应者一次次的 Java 方法调用。 是线程私有的    生命周期\n 生命周期和线程一致。    作用\n 主管 Java 程序的运行，它保存方法的局部变量(8种基本数据类型、对象的引用地址)、部分结果，并参与方法的调用和返回。 局部变量 vs 成员变量（或属性） 基本数据类型 VS 引用类型变量（类、数据、接口）    栈的特点（优点）\n 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。 JVM 直接对 Java 栈的操作只有两个：  每个方法执行，伴随着进栈（入栈、压栈） 执行结束后的出栈工作   对于栈来说不存在垃圾回收问题。    栈中可能出现的异常\n Java 虚拟机规范允许Java 栈的大小是动态的或者是固定不变的。  如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量， Java 虚拟机将会抛出一个 StackOverflowError 异常。 如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 OutOtMemoryError 异常。      设置栈内存大小\n 我们可以使用参数 -Xss 来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 eg: Xss256k    栈中存储什么  每个线程都有自己的栈，栈中的数据都是以**栈帧（Stack Frame）**的格式存在。 在这个线程上正在执行的每个方法都各自对应着一个栈帧（Stack Frame）。 栈帧是一个内存区块，是一个数据集，维系着方法在执行过程中的各种数据信息。  栈运行原理   JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈，遵循 FILO、LIFO 原则。\n  在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。\n  执行引擎运行的字节码指令只针对当前栈帧进行操作。\n  如果在该方法中调用了其方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前栈。\n  不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。\n  如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。\n  Java 方法有两种返回函数的方式，一种是正常的函数返回，使用return指令，另外一种是抛出异常，不管使用哪种方式，都会导致栈帧被弹出。\n  栈帧的内部结构  局部变量表（Local Variables） 操作数栈（Operand Stack)（或表达式栈） 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用） 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义） 一些附加信息\n  局部变量表（Local variables）   局部变量表也被称之为局部变量数组或者本地变量表\n  定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（Reference），以及 returnAddress 类型。\n  由于局部变量表是建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题。\n  局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的 Code 属性的 maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的。\n  方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就会越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占有更多的栈空间，导致其嵌套调用次数就会减少。\n  局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束之后，随着方法栈的销毁，局部变量表也会随之销毁。\n  关于slot的理解   局部变量表，最基本的存储单元是 slot（变量槽）\n  局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型、 returnAddress 类型的变量。\n  在局部变量表里，32位以内的类型只占有一个 slot（包括 returnAddress 类型）,64位的类型（long 和 double）占用两个 Slot。\n byte、short、char 在存储前被转化为 int,boolean 也被转换为 int，0表示 false，非0表示 true。 long 和 double 则占据两个 Slot。\n    JVM 会为局部变量表中的每一个 slot 都分配一个访问索引， 通过这个索引即可成功的访问到局部变量表中指定的局部变量值。\n  当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量就会按照顺序被复制到局部变量表中的每一个slot上。\n  如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问 long 或 double 类型变量。\n  如果当前栈是由构造方法或者实例方法创建的，那么该对象引用 this 将会存放在 index 为0的 slot 处，其余的参数按照参数表顺序继续排列。\n  slot 的重复利用  栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。  局部变量与静态变量的对比  参数表分配完毕之后，再根据方法内定义的变量的顺序和作用域分配。 我们知道类变量表有两次初始化的机会，一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的出事值。 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。  1 2 3 4  public void test(){ int i; System.out.println(i); }   这样的代码是错误的，没有赋值不能使用。\n补充说明  在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。  操作数栈（Operand Stack）   每一个独立的栈帧中除了包含局部变量表之外，还包含一个后进先出(Last-In_-First-Out)的操作数栈，也可以称之为表达式栈(Expression Stack)\n  操作数栈，在方法执行过程中，根据字节码指令，在栈中写入数据或提取数据，即入栈/出栈。\n 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用他们后再把结果压入栈。 比如：执行复制、交换、求和等操作。    操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。\n  操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。\n  每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性中，为 max__stack的值。\n  栈中的任何一个元素都是可以任意的 Java 数据类型。\n 32 bit 的类型占用一个栈单位深度 64 bit 的类型占用两个栈单位深度    操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。\n  如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新pc寄存器中下一条需要执行的字节码指令。\n  操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。\n  另外，我们说 Java 虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。\n  栈顶缓存技术   前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着需要更多的指令分配(instruction dispatch)次数和内存读写次数。\n  由于操作数是存储在内存中的，因此频繁地执行内存读写操作必然会影响执行速度，为了解决这个问题，HotSpot JVM 的设计者们提出来栈顶缓存技术(ToS,Top-of-Stack Cashing), 将栈顶元素全部缓存在物理 CPU 的寄存器中，以此减低对内存的读写次数，提升执行引擎的执行效率。\n  动态链接(或指向运行时常量的方法引用)  每一个栈帧内部都包含一个执行运行是常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如：invokedynamic 指令 在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(Symbolic Reference)保存在 class 文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。  为什么需要常量池呢？  常量池的作用，就是为了提供一些符号和常量，便于指令的识别。  方法的调用   在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关。\n  静态链接：\n 当一个字节码文件被装载进JVM 内部时，如果被调用的目标方法在编译器可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。    动态链接：\n 如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。    对应的方法的绑定机制为：早期绑定和晚期绑定。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。\n  早期绑定：\n 早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟时哪一个，因此也就可以时哟偶能够静态链接的方式将符号引用转换为直接引用。    晚期绑定：\n 如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式就被称之为晚期绑定。    随着高级与演的横空出世，类似于 java 一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是他们彼此之间始终保持这一个共性，那就是支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑和晚期绑定两种绑定方式。\n  Java 中任何一个普通的方法其实都具备虚函数的特征，他们相当于 C++ 语言中的虚函数（C++中则需要使用关键字 virtual 来显示定义）。如果在 Java 程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字 final 来标记这个方法。\n  非虚方法与虚方法  非虚方法   如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的，这样的方法称为非虚方法。\n  静态方法、私有方法、final 方法、实例构造器、父类构造器、父类方法都是非虚方法。\n  其他方法称为虚方法。\n    ","description":"虚拟机栈","id":9,"section":"posts","tags":["JVM","Java"],"title":"虚拟机栈","uri":"http://herschel-ma.github.io/posts/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"},{"content":"PC Register 介绍  JVM 中的程序计数寄存器（Program Counter Register)中，Register 的命名源于 cpu 的寄存器，寄存器存储指令相关的现场信息。CPU 只有把数据装载到寄存器才能够运行。 这里，并非是广义上所指的物理寄存器，或许将其翻译为 PC 计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟。 它是一块很小的内存空间，几乎可以忽略不计，也是运行速度最快的区域。 在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有地，生命周期与线程的生命周期保持一致。 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 地址：或者，如果是在执行 native 方法，则是未指定指（ undefined ）。 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 字节码解释器工作时就是通过改变这个计数器的指来选取下一条需要执行的字节码指令。 它是唯一一个在 Java 虚拟机规范中没有规定任何 OutOtMemoryError 情况的区域。  程序计数器作用  PC 寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。  寄存器的使用举例 示例 1 2 3 4 5 6 7 8 9  public class PCRegisterTest{ public static void main(String[] args) { int a = 10 int b = 20 int c = a + b String s = \u0026#34;abc\u0026#34; System.out.println(s) } }   PCRegister 调用过程 两个常见问题   使用PC寄存器存储字节码指令地址有什么用呢？\n  为什么使用PC寄存器记录当前线程的执行地址呢？\n 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。 JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。    PC 寄存器为什么会被设定为线程私有\n 我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器，这样一来各个线程之间可以进行独立计算，从而不会出现相互干扰的情况。 由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。 这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。    CPU 时间片  CPU 时间片即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。 在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。 但在微观上，由于只有一个 CPU ，一次只能处理程序要求的一部分，如何公平处理，一种方法就是引入时间片，每个程序轮流执行。  ","description":"PC Register","id":10,"section":"posts","tags":["JVM","Java"],"title":"程序计数器","uri":"http://herschel-ma.github.io/posts/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"},{"content":"运行时数据区内部结构   Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机的启动而创建，随着虚拟机退出而销毁(与虚拟机进程对应)。另外一些则是与线程一一对应的，这些与线程对应的数据区会随着线程开始和结束而创建和销毁。\n  灰色的为线程私有的红色的为多个线程共享的，即：\n 每个线程：独立包括程序计数器、栈、本地栈。 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）    关于线程间共享的说明  每个 JVM 只有一个 Runtime 实例。即为运行时环境，相对与内存结构中间的那个框框：运行时环境。  线程   线程是一个程序里的运行单元。JVM 允许一个应用有多个线程并行的执行。\n  在 HotSpot JVM 里，每个线程都与操作系统的本地线程直接映射。\n 当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建，Java 线程执行终止后，本地线程也会被回收。线程回收之后，如果只有守护进程存活，则JVM也会终止。    操作系统负责所有线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用Java线程中的 run() 方法。\n  JVM 系统线程  如果你使用 jconsole 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用 public static void main(String[] args) 的 main 线程以及所有这个 main 线程自己创建的线程。 这些主要的后台系统线程在 HotSpot JVM 里主要是以下几个：  虚拟机线程：这种线程的操作是需要 JVM 达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆才不会变化。这种线程的执行类型包括\u0026quot;stop-the-world\u0026quot;的垃圾收集、线程栈收集、线程挂起以及偏向锁撤销。 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。 GC 线程：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持。 编译线程：这种线程在运行时会将字节码编译成本地代码。 信号调度线程：这种线程接收信号并发送给 JVM ，在它内部通过调用适当的方法进行处理。    ","description":"运行时数据区内部结构","id":11,"section":"posts","tags":["JVM","Java"],"title":"运行时数据区概述及线程","uri":"http://herschel-ma.github.io/posts/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/"},{"content":"关于classLoader  ClassLoader 类，它是一个抽象类，其后所有的类加载器都继承自 ClassLoader (不包括启动类加载器)。 概览     方法名称 描述     getParent() 返回该类加载器的超类加载器   loadClass(String name) 加载名为 name 的类，返回结果为 java.lang.Class 类的实例   findClass(String name) 查找名为 name 的类，返回结果为 java.lang.Class 类的实例   findLoadedClass(String name) 查找名为 name 的已经被加载过的类，返回结果为 java.lang.Class 类的实例   defineClass(String name,byte[] b, int off, int len) 把字节数组中 b 的内容转换为一个 Java 类，返回结果为 java.lang.Class 类的实例   findLoadedClass(String name) 查找名为 name 的已经被加载过的类，返回结果为 java.lang.Class 类的实例    获取 classLoader 的途径   获取当前类的 classLoader\nclass.getClassLoader()\n  获取当前线程上下文的 ClassLoader\nThread.currentThread().getContextClassLoader()\n  获取系统的 ClassLoader\nClassLoader.getSystemClassLoader()\n  获取调用者的 ClassLoader\nDriverManager.getCallerClassLoader()\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public classLoaderTest { public static void main (String[] args) { try{ ClassLoader classLoader = Class.forName(\u0026#34;java.lang.String\u0026#34;).getClassLoader(); System.out.println(classLoader); ClassLoader classLoader1 = Thread.currentThread.getContextClassLoader(); System.out.println(classLoader1); ClassLoader classLoader2 = ClassLoader.getSystemClassLoader.getParent(); System.out.println(classLoader2); }catch(ClassNotFountException e){ e.printStackTrace(); } } }   双亲委派机制 简介  Java虚拟机对 class 文件采取的是按需加载的方式，也就是说当需要使用该类时才将它的 class 文件加载到内存中生成 class 对象。而且加载某个 class 文件时，Java虚拟机采用的是双亲委派模式，即把请求交给父类处理，它是一种任务委派模式。  工作原理  如果一个类加载器收到了类加载请求，他不会自己先去加载，而是把这个请求委托给父类的加载器去执行； 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归；最终请求将会到达顶层的启动类加载器； 如果父类加载器可以完成类加载任务，就成功返回，否则才尝试自己加载，这就是双亲委派机制。  优势  避免类的重复加载 保护程序安全，防止核心 API 被篡改  自定义类 java.lang.String 自定义类 java,lang.ShkStart    沙箱安全机制  自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中的 java/lang/String.class），报错信息说没有main方法，就是因为加载的是 rt.jar 包中的 String 类。这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。  其他   在 JVM 中表示两个 class 对象是否是同一个类存在两个必要条件：\n 类的完整类名必须一致，包括包名。 加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同。    换句话说，在 JVM 中，即使这两个类对象来源于同一个Class文件，被同一个虚拟机所加载，但只要加载他们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。\n  类加载器的引用  JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会将这个类加载器的一个引用作为类型信息的一部分包存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。  类的主动使用和被动使用 Java 程序对类的使用方式分为：主动使用和被动使用。\n  主动使用，又分为7种情况：\n 创建类的实例 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（比如：Class.forName(\u0026lsquo;java.lang.String\u0026rsquo;) 初始化一个类的子类 Java 虚拟机启动时被标明为启动类的类 JDK7 开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果、REF_getStatic、REF_invokeStatic 句柄对应的类没有初始化，则初始化    除了以上七种情况，其他使用 Java 类的方式都被看作是对类的被动使用，都不会导致类的初始化。\n  ","description":"classLoader 的常用方法及获取方法","id":12,"section":"posts","tags":["JVM","Java"],"title":"关于classLoader","uri":"http://herschel-ma.github.io/posts/%E5%85%B3%E4%BA%8Eclassloader/"},{"content":"类加载器与类的加载过程  加载流程     字节码文件 类加载子系统       字节码文件 加载阶段 链接阶段 初始化阶段   字节码文件 引导类加载器 验证 初始化   字节码文件 扩展类加载器 准备 初始化   字节码文件 系统类加载器 解析 初始化     类加载器子系统负责从文件系统或者网络中加载 Class 文件，class 文件在文件的开头有特定的文件标识 ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。 加载的类信息存放与一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量地信息，可能还包括字符串字面量和数字常量（这部分常量信息是 class 文件中常量池部分的内存映射。  类加载器 ClassLoader 角色 s=\u0026gt;start: 开始 in1=\u0026gt;inputoutput: Car.class e=\u0026gt;end: Car实例(car1,car2,...) loader=\u0026gt;operation: ClassLoader load=\u0026gt;operation: 加载并初始化 class=\u0026gt;operation: Car Class instance=\u0026gt;operation: 实例化 s-\u0026gt;in1(right)-\u0026gt;loader-\u0026gt;load(right)-\u0026gt;class(right)-\u0026gt;instance(right)-\u0026gt;e  class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 JVM 当中来根据这个文件实例化出 n 个一模一样的实例。 class file 加载到 JVM 中，被称为 DNA 元数据模板，放在方法区。 在 .class 文件-\u0026gt; JVM -\u0026gt; 最终成为元数据模板，此过程就要一个运输工具（类加载器 ClassLoader），扮演一个快递员的角色。  类的加载过程  代码  1 2 3 4 5 6 7 8  package com.herschel.java public class HelloLoader{ public static void main(String[] args){ System.out.println(\u0026#34;谢谢 ClassLoader 加载我...\u0026#34;) System.out.println(\u0026#34;你的大恩大德，我下辈子来报！\u0026#34;) } }    流程  s=\u0026gt;start: 开始 e=\u0026gt;end: 结束 con1=\u0026gt;condition: 装载类 HelloLoader 了吗？ con2=\u0026gt;condition: ClassLoader 装载顺利 op1=\u0026gt;operation: 链接 op2=\u0026gt;operation: 初始化 HelloLoader op3=\u0026gt;operation: 调用 HelloLoader.main() op4=\u0026gt;operation: 抛出异常 s-\u0026gt;con1 con1(yes)-\u0026gt;op1-\u0026gt;op2(right)-\u0026gt;op3-\u0026gt;e con1(no)-\u0026gt;con2 con2(yes)-\u0026gt;op1 con2(no)-\u0026gt;op4  全流程  graph LR A(加载 Loading)==\u0026gt;B(验证 Verification)==\u0026gt;C(准备 Preparation)--\u0026gt;D(剖析 Resolution)==\u0026gt;E(初始化 Initialization) 加载（Loading）  通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口  链接（Linking） 验证（Verify）  目的在于确保 class 文件的字节流中包含信息符合当前的虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。  准备（Prepare）  为类变量分配内存并且设置该类变量的默认初始值，即零值。 这里不包含用 final 修饰的 static, 因为 final 在编译的时候就会分配了，准备阶段会显示初始化。 这里不会为实例变量分配初始化, 类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。  解析（Resole）  将常量池中的符号引用转换为直接引用的过程 事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行。 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的 class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 解析动作主要针对类或者接口、字段、类方法、接口方法、方法类型等，对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。  初始化  初始化阶段就是执行类构造器方法\u0026lt;clinit\u0026gt;()的过程。 此方法不需要定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 构造器方法中指令按语句在源文件中出现的顺序执行。 \u0026lt;clinit\u0026gt;()不同于类的构造器。（关联：构造器是虚拟机视角下的\u0026lt;init\u0026gt;()) 若该类具有父类，JVM 会保证子类的\u0026lt;clinit\u0026gt;()执行前，父类的\u0026lt;clinit\u0026gt;()已经执行完毕。 虚拟机必须保证一个类的\u0026lt;clinit\u0026gt;()方法在多线程下被同步加锁。  几种类加载器  类加载器分为引导类加载器以及自定义加载器 自定义加载器又分为系统加载器，扩展类加载器以及自己写的加载器\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public class ClassLoaderTest{ public static void main(String[] args) { // 获取系统类加载器  ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader); // sun.misc.launcher$AppClassLoader@18b4aac2  // 获取其上层：扩展类加载器  ClassLoader extClassLoader = systemClassLoader.getParent(); System.out.println(extClassLoader); // sun.misc.launcher$ExtClassLoader@1540e19d  // 获取其上层：获取不到引导类加载器  ClassLoader bootstrapClassLoader = extClassLoader.getParent(); System.out.println(bootstrapClassLoader); // null  } // 对于用户自定义类来说，默认使用系统类加载器进行加载  ClassLoader classLoader = classLoaderTest.class.getClassLoader(); System.out.println(classLoader); // sun.misc.launcher$AppClassLoader@18b4aac2  // String类使用引导类加载器进行加载--\u0026gt; Java 的核心类库都是使用引导类加载器进行加载的  ClassLoader classLoader1 = String.class.getClassLoader(); System.out.println(classLoader1); // null }   虚拟机自带的加载器   启动类加载器（引导类加载器，Bootstrap ClassLoader）\n 这个类加载使用c/c++语言实现的,嵌套在 JVM 内部 它用来加载 Java 的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类 并不继承 java.lang.ClassLoader，没有父加载器。 加载扩展类和应用类加载器，并指定为他们的父类加载器。 处于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类。    扩展类加载器（Extention ClassLoader）\n Java 语言编写，由 sun.misc.launcher$ExtClassLoader 实现 派生于 ClassLoader 类 父类加载器为启动类加载器 从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/lib/ext 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载。    应用程序类加载器（系统类加载器，AppClassLoader）\n java 语言编写，由 sun.misc.launcher$AppClassLoader 实现 派生于 ClassLoader 类 父类加载器为扩展类加载器 它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库 该类加载是程序中默认的类加载器，一般类说，java 应用的类都是由它来完成加载 通过 ClassLoader#getSystemClassLoader() 方法可以获取到该类加载器    ","description":"类加载子系统","id":13,"section":"posts","tags":["JVM","Java"],"title":"类加载子系统","uri":"http://herschel-ma.github.io/posts/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"},{"content":"JVM的整体结构  HotSpot VM是目前市面上高性能虚拟机的代表作之一。 它采用解释器与即时编译器并存的架构。 在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和c/c++程序一较高下的地步。  JVN的架构模型   Java编译器输入的指令流基本上是一种基于栈的指令集架构,另外一种指令集架构则是基于寄存器的指令集架构。\n  区别:\n  基于栈式架构的特点：\n 设计和实现更加简单，适用于资源受限的系统； 避开了寄存器的分配难题，使用零地址指令方式分配； 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现； 不需要硬件支持，可移植性更好，更好实现跨平台。    基于寄存器架构的特点：\n 典型的应用是x86的二进制指令集：比如传统的PC以及Andriod的Davlik虚拟机。 指令集架构则完全依赖硬件，可移植性差。 性能优秀和执行更高效。 花费更少的指令去完成一项操作。 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。      JVM的生命周期 虚拟机的启动  Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initail class）来完成的，这个类是由虚拟及的具体实现指定的。  虚拟机的执行  一个运行中的Java虚拟机有一个清晰的任务：执行Java程序； 程序开始执行时它才运行，程序结束时它就停止； 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。  虚拟机的退出  有如下几种情况：  程序正常执行结束 程序在执行过程中遇到了异常或者错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 某线程调用Runtime类或者System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作 除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或者卸载Java虚拟机时，Java虚拟机的退出情况。    JVM发展历程 Sun Classic VM  早在1996年Java1.0版本的时候，Sun公司发布了一款名叫Sun Classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机,JKD1.4时完全被淘汰。 这款虚拟机内部只提供解释器  虚拟机在解释运行字节吗文件的时候，可以只使用解释器或者JIT（即时编译器）   如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。 现在hotspot内置了此虚拟机。  Exact VM  为了解决上一个虚拟机问题，在jdk1.2时，sun 提供了此虚拟机 Exact Memory Management: 准确式内存管理  也可以叫Non-Conservative/Accurate Memory Management 虚拟机可以知道内存中某个为之的数据具体是什么类型。   具体被现代高性能虚拟机的雏形  热点探测 编译器与解释器混合工作模式   只在Solaris平台短暂使用，其他平台还是classic VM  英雄气短，后被Hotspot虚拟机代替    HotSpot VM   HotSpot历史\n 最初由一家名为“Longview Technologies”的小公司设计 1997年，此公司被Sun收购；2009年，Sun公司被Oracle收购。 JDK1.3时，HotSpot VM成为默认虚拟机。    目前Hotspot占有绝对的市场地位，称霸武林\n 不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是Hotspot. Sun/Oracle JDK 和 OpenJDK的默认虚拟机    从服务器、桌面到移动端、嵌入式都有应用。\n  名称中的HotSpot指的是它的热点代码探测技术。\n 通过计数器找到最具编译价值的代码，触发即时编译或栈上替换 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡。    BEA的JRockit  专注于服务器端应用  它可以不太关注程序启动速度，因此JRockit内部不包含解释器实现，全部代码都靠即时编译器编译后执行。   大量的行业基准测试显示，JRockit是世界上最快的JVM.  使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。   优势：全面的Java运行时解决方案组合。  JRockit 面向延迟敏感型应用的解决方案 JRockit Real Time 提供以毫秒或微妙级别的 JVM 响应时间，适合财务、军事指挥、电信网络的需要。 MissionControl 服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。   2008年，BEA 被 Oracle 收购。 Oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成，整合的方式是在 HotSpot 的基础上，移植 JRockit 的优秀特性。 高斯林：目前就职于谷歌，研究人工智能和水下机器人。  IBM 的 J9  全称：IBM Technology for Java Virtual Machine,简称IT4J，内部代号：J9。 市场定位与 HotSpot 接近，服务器端、桌面应用、嵌入式等多用途 VM 广泛用于 IBM 的各种 Java 产品。 目前， 有影响力的三大商用虚拟机之一, 也号称是世界上最快的 Java 虚拟机。 2017年左右，IBM 发布了开源 J9 VM，命名为 OpenJ9，交给 Eclipse基金会管理，也称为 Eclipse OpenJ9  ","description":"认识JVM","id":14,"section":"posts","tags":["JVM","Java"],"title":"认识JVM","uri":"http://herschel-ma.github.io/posts/%E8%AE%A4%E8%AF%86jvm/"},{"content":"TypeScript的介绍 TypeScript是一种有微软开发的开源，跨平台的编程语言，最终会被编译成为JavaScript代码。\n2012年10月，微软发布了首个公开版本的TypeScript，2013年6月19日，在经历到了一个预览版之后微软正式发布了正式版TypeScript.\nTypeScript的作者是安德斯-海尔斯伯格，C#的首席架构师，它是开源和跨平台的编程语言。\nTypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以运行在TypeScript环境中。\nTypeScript是为大型应用的开发而设计，并且可以编译为JavaScript。\nTypeScript是JavaScript的一个超集，主要提供了类型系统和对ES6+的支持，它由Microsoft开发，代码开源于Github上。\nTypeScript的特点   始于JavaScipt,归于JavaScript\nTypeScript可以编译出纯净、简洁的JavaScript代码，并且可以运行在任何浏览器上，Node.js环境中和任何支持ECMAScript3（或更高版本）的JavaScript引擎中。\n  强大的类型系统\n类型系统允许JavaScript开发者在开发JavaScript应用程序是使用高效的开发工具和常用操作，比如静态检查和代码重构。\n  先进的JavaScript\nTypeScript提供最新的和不断发展的JavaScript特性，包括那些来自2015年的ECMAScript和未来的提案中的特性，比如异步功能和Decrators，以帮助建立健壮的组件。\n  小结 TypeScript在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。\nTypeScript的安装 命令行如下，全局安装TypeScript\n1  npm i -g typescript   安装完之后，输入以下命令查看是否安装成功：\n1  tsc -V   类型注解 类型注解是一种轻量级的为函数或者变量添加的约束。\n1 2 3 4 5 6 7  (()=\u0026gt;{ function showMsg(msg:string) { return \u0026#34;hello,\u0026#34; + msg } let msg = \u0026#34;迪儿\u0026#34; console.log(showMsg(msg)) })()   接口 接口是一种能力， 一种约束。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  (()=\u0026gt;{ // define an interface  interface IPerson { firstName: string lastName: string } // print name  function showFullName(person:IPerson) { return person.firstName + \u0026#39;_\u0026#39; + person.lastName } // define an object  const person = { firstName: \u0026#39;东方\u0026#39; lastName: \u0026#39;不败\u0026#39; } console.log(showFullName(person)) })()   ","description":"TypeScript之旅","id":15,"section":"posts","tags":["TypeScript"],"title":"认识TypeScript","uri":"http://herschel-ma.github.io/posts/%E8%AE%A4%E8%AF%86typescript/"},{"content":"封装 成员变量私有化，提供公共的getter和setter给外界去访问成员变量\nclass和struct c++中class和struct就是类，唯一的区别的是 class 定义的类对象，默认情况下成员变量和方法是私有的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #include \u0026lt;iostream\u0026gt;using namespace std; struct Person { private: int m_age; public: void setAge(int age) { if (age \u0026lt;= 0) return; m_age = 1 } else { m_age = age } int getAge() { return m_age; } }; int main() { Person person; // person.m_age = -4 访问不到  person.setAge(-4); getchar(); // 等待直到输入一个字符  return 0; }   内存空间的布局 每个应用都有自己独立的内存空间，其内存空间一般都有以下几大区域\n  代码段（代码区）\n用于存放代码\n  数据段（全局区）\n用于存放全局变量\n  栈空间\n用于存放局部变量等，每调用一个函数就会给它分配一段连续的栈空间，等函数调用完成之后释放栈空间\n自动分配和回收\n  堆空间\n需要主动去申请和释放\n在程序运行过程中，为了能自由控制内存的生命周期、大小，会经常使用堆空间的内存\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;iostream\u0026gt;using namespace std; void test() { int *p = (int*)malloc(4); // 从堆空间中获取4个字节的内存空间，返回连续空间的首内存地址  *p = 10; free(p); // 堆空间必须手动释放  char *t = new char[4] delete[] t; } int main() { test(); getchar(); return 0; }   堆空间的初始化 malloc和new的区别 malloc不会初始化对象，而new会\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include\u0026lt;iostream\u0026gt;using namespace std; void test() { int *p0 = new int(); // 会初始化  int *p1 = new int[3]; // 不会初始化  int *p2 = new int[3](); // 会初始化  int *p3 = new int[3]{5}; // 将数组首位初始化为5，其他仍为0  cout \u0026lt;\u0026lt; *p0 \u0026lt;\u0026lt; endl; // 输出 } int main() { int *p = (int*)malloc(sizeof(int)*10) // 申请40个字节的堆空间  *p = 1; // 将第一个字节地址赋值为1  // 从p地址开始的连续4个字节中的每一个字节都设置为1  // memset(p, 1, 4)  // 00000001 00000001 00000001 00000001  // 将四个字节设置为1  // 00000000 00000000 00000000 00000000  test() getchar; return 0; }   对象内存 对象的内存可以放到全局区，堆空间或者栈空间\n","description":"封装 内存空间 堆空间","id":16,"section":"posts","tags":["c++"],"title":"面向对象","uri":"http://herschel-ma.github.io/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":17,"section":"","tags":null,"title":"About","uri":"http://herschel-ma.github.io/about/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":18,"section":"gallery","tags":null,"title":"Cartoon","uri":"http://herschel-ma.github.io/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":19,"section":"gallery","tags":null,"title":"Photo","uri":"http://herschel-ma.github.io/gallery/photo/"}]