---
title: "堆空间的概述"
date: 2021-03-16T21:20:49+08:00
draft: false
description: ""
draft: false
hideToc: false
enableToc: true
enableTocContent: true
author: Herschel
authorEmoji: 🎅
pinned: false
tags:
- JVM
- java
series:
-
categories:
- java
image:
---
## 堆的核心概述
- 一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。
- Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存空间。
    - 堆内存的大小是可以调节的。
- 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在**逻辑上**它应该被视为**连续的**。
- 所有的线程共享 Java 堆，在这里还可以划分为线程私有的缓冲区（Thread Local Allocation Buffer,TLAB）。
- 《Java虚拟机规范》中对 Java 堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instance and arrays is allocated）
    - “几乎”所有的对象实例都在这里分配内存。——从世界使用角度看的
- 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。
- 在方法结束后，堆的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
- 堆，是 GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。
## 内存细分
- Java 8 及之后堆内存逻辑上分为三部分：新生区、养老区、元空间。
## 设置堆内存大小与 OOM
- Java 堆区用于存储 Java 对象实例，那么堆的大小在 JVM 启动时就已经设定好了，大家可以通过“-Xmx”和“-Xms”来进行设置。
    - “-Xms”用于表示堆区的起始内存，等价于 -XX：InitialHeapSize
    - “-Xmx”则用于表示堆区的最大内存，等价于 -XX：MaxHeapSize
- 一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出 OutOfMemoryError 异常。
- 通常会将 -Xms 和 -Xmx 两个参数配置相同的值，其**目的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能**。
- 默认情况下，初始内存大小：物理电脑内存大小/64， 最大内存大小：物理电脑内存大小/4。

## 年轻代与老年代
- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。
- 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与 JVM 的生命周期保持一致。

- Java 堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）
- 其中年轻代又可以划分为 Eden 空间，Survivor0 空间和 Survivor1 空间（有时也叫做 from 区、to 区）。

- 下面这参数开发中一般不会调：
    - 默认 -XX：NewRatio=2,表示新生代占1，老年代占2，新生代占整个堆的1/3
    - 可以修改 -xx:NewRatio=4, 表示新生代占1，老年代占4，新生代占整个堆的1/5。

- 在 HotSpot 中，Eden 空间和另外两个 Survivor 空间缺省所占的比例是 8:1:1

- 当然开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如-XX：SurvivorRatio=8
    - `XX:SurvivorRatio`:设置新生代中Eden区与Survivor区的比例
    - `XX:-useAdaptiveSizePolicy`:关闭自适应的内存分配策略（暂时用不到）

- 几乎所有的 Java 对象都是在 Eden 区被 new 出来的
- 绝大部分的 Java 对象的销毁都在新生代进行了。
    - IBM 公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。
- 可以使用选项“-Xmn”设置新生代最大内存大小
    - 这个参数一般使用默认值就可以了。

## 对象分配过程：概述
- 为新对象分配内存是一件非常严谨而复杂的任务，JVM的设计者们不仅需要考内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完毕内存回收后是否会在内存空间中产生内存碎片。
1. new 的对象先放在伊甸园区，此区有大小限制。
2. 当伊甸园的空间填满时，程序又要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到伊甸园区。
3. 然后将伊甸园区中的剩余对象移动到幸存者0区。
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。
5. 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。
6. 啥时候能去养老区呢？可以设置次数，默认是15次。
    - 可以设置参数: `-XX:MaxTenuringThreshold=<N>`进行设置。
### 总结
- **针对幸存者 s0，s1 区的总结：复制之后有交换，谁空谁是to.**
- **关于垃圾回收：频繁再新生区收集，很少在养老区收集，几乎不在永久区/元空间收集**

## 常用调优工具
- JDK命令行
- Eclipse: Memory Analyzer Tool
- Jconsole
- Visual VM
- Jprofiler
- Java Flight Recorder
- GCViewer
- GC Easy

