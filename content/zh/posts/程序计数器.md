---
title: "程序计数器"
date: 2021-02-13T16:28:00+08:00
description: "PC Register"
draft: false
hideToc: false
enableToc: true
enableTocContent: true
author: Herschel
authorEmoji: 🦊
pinned: false
tags:
- JVM
- Java
series:
-
categories:
- Java
image: images/JVM/程序计数器.png
---
## PC Register 介绍
![程序计数器](/images/JVM/程序计数器.png)
- JVM 中的程序计数寄存器（Program Counter Register)中，Register 的命名源于 cpu 的寄存器，寄存器存储指令相关的现场信息。CPU 只有把数据装载到寄存器才能够运行。
- 这里，并非是广义上所指的物理寄存器，或许将其翻译为 PC 计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。**JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟**。
-  它是一块很小的内存空间，几乎可以忽略不计，也是运行速度最快的区域。
- 在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有地，生命周期与线程的生命周期保持一致。
- 任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 地址：或者，如果是在执行 native 方法，则是未指定指（ undefined ）。
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
- 字节码解释器工作时就是通过改变这个计数器的指来选取下一条需要执行的字节码指令。
- 它是唯一一个在 Java 虚拟机规范中没有规定任何 OutOtMemoryError 情况的区域。

## 程序计数器作用
![程序计数器作用](/images/JVM/程序寄存器作用.png)
- PC 寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。

## 寄存器的使用举例
### 示例
```java
public class PCRegisterTest{
    public static void main(String[] args) {
        int a = 10
        int b = 20
        int c = a + b
        String s = "abc"
        System.out.println(s)
    }
}
```
### PCRegister 调用过程
![寄存器的使用](/images/JVM/寄存器操作过程.png)

## 两个常见问题
- 使用PC寄存器存储字节码指令地址有什么用呢？
- 为什么使用PC寄存器记录当前线程的执行地址呢？
    - 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。
    - JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。

- PC 寄存器为什么会被设定为线程私有
    - 我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？**为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器**，这样一来各个线程之间可以进行独立计算，从而不会出现相互干扰的情况。
    - 由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。
    - 这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。

## CPU 时间片
- CPU 时间片即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。
- 在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。
- 但在微观上，由于只有一个 CPU ，一次只能处理程序要求的一部分，如何公平处理，一种方法就是引入时间片，每个程序轮流执行。


